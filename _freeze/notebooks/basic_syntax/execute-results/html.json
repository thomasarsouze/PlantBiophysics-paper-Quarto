{
  "hash": "a4582aec78619ee0580a1089126fd1e5",
  "result": {
    "markdown": "---\ntitle: Get started with Julia - live\n---\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n### A Pluto.jl notebook ###\n# v0.19.27\n\nusing Markdown\nusing InteractiveUtils\n```\n:::\n\n\n\nBefore being able to run this notebook succesfully locally, you will need to [set up Julia and Pluto.](/Spring21/installation/)\n\n\n\n## Variables\n\nWe can define a variable using `=` (assignment). Then we can use its value in other expressions:\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nx = 3\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n3\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\ny = 2x\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n6\n```\n:::\n:::\n\n\nBy default Julia displays the output of the last operation. (You can suppress the output by adding `;` (a semicolon) at the end.)\n\n\nWe can ask what type a variable has using `typeof`:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nInt64\n```\n:::\n:::\n\n\n## Functions\n\nWe can use a short-form, one-line function definition for simple functions:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nf(x) = 2 + x\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nf (generic function with 1 method)\n```\n:::\n:::\n\n\nTyping the function's name gives information about the function. To call it we must use parentheses:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nf (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nf(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n12\n```\n:::\n:::\n\n\nFor longer functions we use the following syntax with the `function` keyword and `end`:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nfunction g(x, y)\n\tz = x + y\n\treturn z^2\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\ng (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\ng(1, 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n9\n```\n:::\n:::\n\n\n## For loops\n\nUse `for` to loop through a pre-determined set of values:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nlet s = 0\n\t\n\tfor i in 1:10\n\t\ts += i    # Equivalent to s = s + i\n\tend\n\t\n\ts\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n55\n```\n:::\n:::\n\n\nHere, `1:10` is a **range** representing the numbers from 1 to 10:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\ntypeof(1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nUnitRange{Int64}\n```\n:::\n:::\n\n\nAbove we used a `let` block to define a new local variable `s`. \nBut blocks of code like this are usually better inside functions, so that they can be reused. For example, we could rewrite the above as follows:\n\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nfunction mysum(n)\n\ts = 0\n\t\n\tfor i in 1:n\n\t\ts += i    \n\tend\n\t\n\treturn s\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nmysum (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nmysum(100)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n5050\n```\n:::\n:::\n\n\n## Conditionals: `if`\n\nWe can evaluate whether a condition is true or not by simply writing the condition:\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\na = 3\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n3\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\na < 5\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\ntrue\n```\n:::\n:::\n\n\nWe see that conditions have a Boolean (`true` or `false`) value. \n\nWe can then use `if` to control what we do based on that value:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nif a < 5\n\t\"small\"\n\t\nelse\n\t\"big\"\n\t\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n\"small\"\n```\n:::\n:::\n\n\nNote that the `if` also returns the last value that was evaluated, in this case the string `\"small\"` or `\"big\"`, Since Pluto is reactive, changing the definition of `a` above will automatically cause this to be reevaluated!\n\n## Arrays\n\n### 1D arrays (`Vector`s)\n\nWe can make a `Vector` (1-dimensional, or 1D array) using square brackets:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\nv = [1, 2, 3]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n3-element Vector{Int64}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\ntypeof(v)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Vector{Int64}<span class=\"ansi-bright-black-fg\"> (alias for </span><span class=\"ansi-bright-black-fg\">Array{Int64, 1}</span><span class=\"ansi-bright-black-fg\">)</span></pre>\n```\n:::\n\n:::\n:::\n\n\nThe `1` in the type shows that this is a 1D array.\n\nWe access elements also using square brackets:\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nv[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n2\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nv[2] = 10\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n10\n```\n:::\n:::\n\n\nNote that Pluto does not automatically update cells when you modify elements of an array, but the value does change.\n\nA nice way to create `Vector`s following a certain pattern is to use an **array comprehension**:\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\nv2 = [i^2 for i in 1:10]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n```\n:::\n:::\n\n\n### 2D arrays (matrices)\n\nWe can make small matrices (2D arrays) with square brackets too:\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nM = [1 2\n\t 3 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.julia .cell-code}\ntypeof(M)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>Matrix{Int64}<span class=\"ansi-bright-black-fg\"> (alias for </span><span class=\"ansi-bright-black-fg\">Array{Int64, 2}</span><span class=\"ansi-bright-black-fg\">)</span></pre>\n```\n:::\n\n:::\n:::\n\n\nThe `2` in the type confirms that this is a 2D array.\n\nThis won't work for larger matrices, though. For that we can use e.g.\n\n::: {.cell execution_count=24}\n``` {.julia .cell-code}\nzeros(5, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n5×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n```\n:::\n:::\n\n\nNote that `zeros` gives `Float64`s by default. We can also specify a type for the elements:\n\n::: {.cell execution_count=25}\n``` {.julia .cell-code}\nzeros(Int, 4, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n4×5 Matrix{Int64}:\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n 0  0  0  0  0\n```\n:::\n:::\n\n\nWe can then fill in the values we want by manipulating the elements, e.g. with a `for` loop.\n\nA nice alternative syntax to create matrices following a certain pattern is an array comprehension with a *double* `for` loop:\n\n::: {.cell execution_count=26}\n``` {.julia .cell-code}\n[i + j for i in 1:5, j in 1:6]\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n5×6 Matrix{Int64}:\n 2  3  4  5   6   7\n 3  4  5  6   7   8\n 4  5  6  7   8   9\n 5  6  7  8   9  10\n 6  7  8  9  10  11\n```\n:::\n:::\n\n\n\n# Acknowledgement\n\n\n\n\t\t\n_**Computational Thinking**, a live online Julia/Pluto textbook._ ([computationalthinking.mit.edu](https://computationalthinking.mit.edu), [original notebook](https://github.com/mitmath/18S191/blob/Fall20/lecture_notebooks/Basic%20Julia%20syntax.jl))\n\n\n",
    "supporting": [
      "basic_syntax_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}